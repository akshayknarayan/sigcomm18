\section{CCP Implementation}
\label{s:datapath}
%
\subsection{Overview of the Linux fast path implementation}
\label{sec:implementation-basics}

An implementation of the CCP fast path must perform the following functions:
\begin{itemize}
\item The fast path should communicate with a \userspace CCP agent using an IPC
  mechanism. The fast path multiplexes \ct{report}s from multiple connections
  onto the single persistent IPC connection to the slow path.
\item The fast path should execute the user-provided domain-specific program on
  the arrival of every acknowledgment or a timeout in a safe manner. Fast path
  programs (\Sec{sec:ccp}) may include simple computations to summarize
  per-packet congestion signals (Table~\ref{tab:api}) and enforce congestion
  windows and rates.
\end{itemize}

We have implemented a Linux kernel fast path as a kernel
module over the Linux 4.14 kernel. The module
implements the communication channel to the slow path using either netlink sockets or a custom
character device.

Our kernel module leverages the pluggable TCP API to invoke the program
interpreter upon arrivals of packet acknowledgments and timeouts.
%
\begin{table}
    \centering
    \footnotesize
    \begin{tabular}{p{0.35\columnwidth}p{0.5\columnwidth}}
        \textbf{Signal} & \textbf{Definition} \\
        \hline
        \texttt{Ack.bytes\_acked}, \texttt{Ack.packets\_acked}             & \texttt{Delta(tcp\_sock.bytes\_acked)} \\
        \texttt{Ack.bytes\_misordered}, \texttt{Ack.packets\_misordered}   & \texttt{Delta(tcp\_sock.sacked\_out)} \\
        \texttt{Ack.ecn\_bytes}, \texttt{Ack.ecn\_packets}                 & \texttt{in\_ack\_event: CA\_ACK\_ECE} \\
        \texttt{Ack.lost\_pkts\_sample}                                    & \texttt{rate\_sample.losses} \\
        \texttt{Ack.now}                                                   & \texttt{getnstimeofday()}\\
        \texttt{Flow.was\_timeout}                                         & \texttt{set\_state: TCP\_CA\_Loss} \\
        \texttt{Flow.rtt\_sample\_us}                                      & \texttt{rate\_sample.rtt\_us} \\
        \texttt{Flow.rate\_outgoing}                                       & \texttt{rate\_sample.delivered / Delta(tcp\_sock.first\_tx\_mstamp)} \\
        \texttt{Flow.rate\_incoming}                                       & \texttt{rate\_sample.delivered / Delta(tcp\_sock.tcp\_mstamp)}  \\
        \texttt{Flow.bytes\_in\_flight}, \texttt{Flow.packets\_in\_flight} & \texttt{tcp\_packets\_in\_flight(tcp\_sock)} \\
    \end{tabular}
    %\vspace{0.075in}
    \caption{Definition of CCP primitives in terms of \texttt{tcp\_sock} state.}\label{tab:api:kernel}
\end{table}
Our implementation extracts primitive congestion signals from the
\ct{tcp\_sock} and \ct{rate\_sample} structures.

Table ~\ref{tab:api:kernel} details the mapping of kernel variables
to CCP primitives.
%
The module enforces congestion windows and sending rates using the corresponding
members of the \ct{tcp\_sock} and \ct{sock} structures (\ct{snd\_cwnd} and
\ct{sk\_pacing\_rate}, respectively).

This definition of primitives and enforcement mechanisms is the only datapath-specific
work needed to support CCP; all other functionality is shared amongst software datapaths
via the program interpreter: \texttt{libccp}. In addition to Linux, we have already integrated
\ct{libccp} into CCP fast path implementations running inside Intel DPDK and
QUIC.

\subsection{Safe Execution of fast path programs}
\label{s:datapath:fold}
Datapaths are responsible for safely executing the fast path program sent from the userspace CCP module. While CCP will serialize the instructions and check for mundane errors (e.g., use of undefined variables) before installation, it is the datapath’s responsibility to ensure safe interpretation of the instructions. For example, datapaths should prevent divide by zero errors when calculating user defined variables and guarantee that programs cannot overwrite the congestion primitives.

Thankfully, this task is straightforward as fast path programs are limited in functionality.
Programs may not enter loops, perform floating point operations, define functions or data structures, allocate memory, or access arbitrary memory addresses; programs are strictly a way to express arithmetic computations over a limited set of primitives, define when and how to set congestion windows and pacing rates, and report measurements.

We have implemented a library, \ct{libccp}, that provides a reference
implementation of CCP's datapath component; \ie an execution environment for
user-specified datapath behavior and message serialization for software
datapaths. While we considered using eBPF~\cite{ebpf} or TCP BPF~\cite{tcpbpf}
for this functionality, using our own lightweight virtual machine, \ct{libccp},
allowed us to port our CCP implementations to other datapaths outside the
kernel, such as QUIC, with minimal effort.

\subsection{\ct{libccp}: a fast path program interpreter}
\label{s:datapath:libccp}
To use \ct{libccp}, the datapath must provide callbacks to functions that: (1) set the window and rate, (2) provide a notion of time, and (3) send an IPC message to CCP. Upon read- ing a message from CCP, the datapath calls \ct{ccp\_recv\_msg()}, which automatically demultiplexes the message for the correct flow. After updating congestion signals, the datapath can call \ct{ccp\_invoke()}, which automatically runs the fastpath program, which may update variable calculations, set windows or rates, and send report summaries to the CCP. It is the responsibility of the datapath to ensure that it correctly computes and provides the congestion signals in Table 1.
The more signals a datapath can measure, the more algorithms that datapath can support. For example, CCP can only support DCTCP \cite{DCTCP} or ABC \cite{abc} on datapaths that provide ECN support; CCP will not run algorithms on datapaths lacking support for that algorithm’s requisite primitives.
