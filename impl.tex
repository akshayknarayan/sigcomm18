\subsection{Overview of the Linux fast path implementation}
\label{sec:implementation-basics}

An implementation of the CCP fast path must perform the following functions:
\begin{itemize}
\item The fast path should communicate with a \userspace CCP agent using an IPC
  mechanism. The fast path multiplexes \ct{report}s from multiple connections
  onto the single persistent IPC connection to the slow path.
\item The fast path should execute the user-provided domain-specific program on
  the arrival of every acknowledgment or a timeout in a safe manner. Fast path
  programs (\Sec{sec:ccp}) may include simple computations to summarize
  per-packet congestion signals (Table~\ref{tab:api}) and enforce congestion
  windows and rates.
\end{itemize}

We have implemented a Linux kernel fast path as a kernel
module over the Linux 4.14 kernel. The module
implements the communication channel to the slow path using either netlink sockets or a custom
character device.

Our kernel module leverages the pluggable TCP API to invoke the program
interpreter upon arrivals of packet acknowledgments and timeouts.
%
\begin{table}
    \centering
    \footnotesize
    \begin{tabular}{p{0.35\columnwidth}p{0.5\columnwidth}}
        \textbf{Signal} & \textbf{Definition} \\
        \hline
        \texttt{Ack.bytes\_acked}, \texttt{Ack.packets\_acked}             & \texttt{Delta(tcp\_sock.bytes\_acked)} \\
        \texttt{Ack.bytes\_misordered}, \texttt{Ack.packets\_misordered}   & \texttt{Delta(tcp\_sock.sacked\_out)} \\
        \texttt{Ack.ecn\_bytes}, \texttt{Ack.ecn\_packets}                 & \texttt{in\_ack\_event: CA\_ACK\_ECE} \\
        \texttt{Ack.lost\_pkts\_sample}                                    & \texttt{rate\_sample.losses} \\
        \texttt{Ack.now}                                                   & \texttt{getnstimeofday()}\\
        \texttt{Flow.was\_timeout}                                         & \texttt{set\_state: TCP\_CA\_Loss} \\
        \texttt{Flow.rtt\_sample\_us}                                      & \texttt{rate\_sample.rtt\_us} \\
        \texttt{Flow.rate\_outgoing}                                       & \texttt{rate\_sample.delivered / Delta(tcp\_sock.first\_tx\_mstamp)} \\
        \texttt{Flow.rate\_incoming}                                       & \texttt{rate\_sample.delivered / Delta(tcp\_sock.tcp\_mstamp)}  \\
        \texttt{Flow.bytes\_in\_flight}, \texttt{Flow.packets\_in\_flight} & \texttt{tcp\_packets\_in\_flight(tcp\_sock)} \\
    \end{tabular}
    %\vspace{0.075in}
    \caption{Definition of CCP primitives in terms of \texttt{tcp\_sock} state.}\label{tab:api:kernel}
\end{table}
Our implementation extracts primitive congestion signals from the
\ct{tcp\_sock} and \ct{rate\_sample} structures.

Table ~\ref{tab:api:kernel} details the mapping of kernel variables
to CCP primitives.
%
The module enforces congestion windows and sending rates using the corresponding
members of the \ct{tcp\_sock} and \ct{sock} structures (\ct{snd\_cwnd} and
\ct{sk\_pacing\_rate}, respectively).

This definition of primitives and enforcement mechanisms is the only datapath-specific
work needed to support CCP; all other functionality is shared amongst software datapaths
via the program interpreter: \texttt{libccp}. In addition to Linux, we have already integrated
\ct{libccp} into CCP fast path implementations running inside Intel DPDK and
QUIC.
